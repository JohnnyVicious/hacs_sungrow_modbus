import logging
from datetime import UTC, datetime, timedelta

from homeassistant.components.sensor import RestoreSensor, SensorEntity
from homeassistant.core import HomeAssistant, callback

from custom_components.sungrow_modbus.const import CONTROLLER, DOMAIN, REGISTER, SLAVE, VALUE
from custom_components.sungrow_modbus.data.enums import InverterType, PollSpeed
from custom_components.sungrow_modbus.helpers import cache_get, is_correct_controller
from custom_components.sungrow_modbus.sensors.sungrow_base_sensor import SungrowBaseSensor

_LOGGER = logging.getLogger(__name__)
_WATCHDOG_TIMEOUT_MIN = 10


class SungrowSensor(RestoreSensor, SensorEntity):
    """Representation of a Modbus sensor."""

    def __init__(self, hass: HomeAssistant, sensor: SungrowBaseSensor):
        self._hass = hass
        self.base_sensor = sensor

        self._attr_name = sensor.name
        self._attr_has_entity_name = True
        self._attr_unique_id = sensor.unique_id

        self._register: list[int] = sensor.registrars

        self._device_class = sensor.device_class
        self._unit_of_measurement = sensor.unit_of_measurement
        self._attr_device_class = sensor.device_class
        self._attr_state_class = sensor.state_class
        self._attr_native_unit_of_measurement = sensor.unit_of_measurement
        self._attr_available = not sensor.hidden
        self._attr_suggested_display_precision = self.decimal_count(sensor.multiplier)

        self.is_added_to_hass = False
        self._state = None
        self._received_values = {}
        self.poll_speed = sensor.poll_speed

        # Watchdog parameters
        self._last_update = datetime.now(UTC).astimezone()
        self._update_timeout = timedelta(
            minutes=self.base_sensor.controller.poll_speed.get(sensor.poll_speed, 0) + _WATCHDOG_TIMEOUT_MIN
        )

    def decimal_count(self, number: float) -> int | None:
        """Returns the number of decimal places in a given number."""
        if self.device_class is None:
            return None
        if number == int(number):  # Whole number
            return 0

        str_number = str(number).rstrip("0")  # Convert to string and remove trailing zeros
        decimal_part = str_number.split(".")[-1]  # Get the decimal part

        return len(decimal_part)

    async def async_added_to_hass(self) -> None:
        await super().async_added_to_hass()
        state = await self.async_get_last_sensor_data()
        if state:
            self._attr_native_value = state.native_value
        self.is_added_to_hass = True

        # Register event listener for real-time updates and store unsubscribe callback
        self._unsub_listener = self._hass.bus.async_listen(DOMAIN, self.handle_modbus_update)

    async def async_will_remove_from_hass(self) -> None:
        """Cleanup when entity is removed."""
        if hasattr(self, "_unsub_listener") and self._unsub_listener:
            self._unsub_listener()
            self._unsub_listener = None
        await super().async_will_remove_from_hass()

    @callback
    def handle_modbus_update(self, event):
        """Callback function that updates sensor when  register data is available."""
        updated_register = int(event.data.get(REGISTER))
        updated_controller = str(event.data.get(CONTROLLER))
        updated_controller_slave = int(event.data.get(SLAVE))

        if not is_correct_controller(self.base_sensor.controller, updated_controller, updated_controller_slave):
            return  # meant for a different sensor/inverter combo

        if updated_register in self._register:
            # Causes issues with grid inverters going offline, and messing up energy dashboard
            if (
                self.base_sensor.controller.inverter_config.type == InverterType.GRID
                and updated_register == 3014
                and cache_get(self.hass, 3043, self.base_sensor.controller.controller_key) == 2
            ):
                self._attr_native_value = 0
                self.schedule_update_ha_state()
                self._last_update = datetime.now(UTC).astimezone()
                return

            updated_value = int(event.data.get(VALUE))
            self._received_values[updated_register] = updated_value

            # If we haven't received all registers yet, wait
            if not all(reg in self._received_values for reg in self._register):
                _LOGGER.debug(f"not all values received yet = {self._received_values}")
                return

            values = [self._received_values[reg] for reg in self._register]
            if None in values:
                problematic_regs = {
                    reg: self._received_values.get(reg)
                    for reg in self._register
                    if self._received_values.get(reg) is None
                }
                if problematic_regs:
                    _LOGGER.debug(f"⚠️ Problematic values received in registrars: {problematic_regs}, skipping update")
                    return

            new_value = self.base_sensor.convert_value(values)
            # Clear received values after update
            self._received_values.clear()

            # Update state if valid value exists
            if new_value is not None:
                self._attr_native_value = new_value
                self._attr_available = True
                self._last_update = datetime.now(UTC).astimezone()
                self.schedule_update_ha_state()

    async def async_update(self):
        """Fallback-Check: If no update for more than _WATCHDOG_TIMEOUT_MIN minutes, set values to 0 or unavailable"""
        now = datetime.now(UTC).astimezone()
        if (now - self._last_update > self._update_timeout) and self.poll_speed != PollSpeed.ONCE:
            _LOGGER.warning(
                f"⚠️ No Modbus update for sensor {self._attr_name} in over {_WATCHDOG_TIMEOUT_MIN} minutes. Setting to 0."
            )
            # self._attr_native_value = 0
            self._attr_available = False  # Set attribute unavailable (if desired)
            self.schedule_update_ha_state()

    @property
    def device_info(self):
        """Return device info."""
        return self.base_sensor.controller.device_info

    @property
    def extra_state_attributes(self):
        """Return extra state attributes."""
        attrs = {}
        # Expose raw numeric value when value mapping is used
        if self.base_sensor.has_value_mapping and self.base_sensor.raw_value is not None:
            attrs["raw_value"] = self.base_sensor.raw_value
        return attrs if attrs else None
